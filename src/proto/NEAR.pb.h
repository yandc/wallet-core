// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NEAR.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_NEAR_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_NEAR_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_NEAR_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_NEAR_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_NEAR_2eproto;
namespace TW {
namespace NEAR {
namespace Proto {
class AccessKey;
class AccessKeyDefaultTypeInternal;
extern AccessKeyDefaultTypeInternal _AccessKey_default_instance_;
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class AddKey;
class AddKeyDefaultTypeInternal;
extern AddKeyDefaultTypeInternal _AddKey_default_instance_;
class CreateAccount;
class CreateAccountDefaultTypeInternal;
extern CreateAccountDefaultTypeInternal _CreateAccount_default_instance_;
class DeleteAccount;
class DeleteAccountDefaultTypeInternal;
extern DeleteAccountDefaultTypeInternal _DeleteAccount_default_instance_;
class DeleteKey;
class DeleteKeyDefaultTypeInternal;
extern DeleteKeyDefaultTypeInternal _DeleteKey_default_instance_;
class DeployContract;
class DeployContractDefaultTypeInternal;
extern DeployContractDefaultTypeInternal _DeployContract_default_instance_;
class FullAccessPermission;
class FullAccessPermissionDefaultTypeInternal;
extern FullAccessPermissionDefaultTypeInternal _FullAccessPermission_default_instance_;
class FunctionCall;
class FunctionCallDefaultTypeInternal;
extern FunctionCallDefaultTypeInternal _FunctionCall_default_instance_;
class FunctionCallPermission;
class FunctionCallPermissionDefaultTypeInternal;
extern FunctionCallPermissionDefaultTypeInternal _FunctionCallPermission_default_instance_;
class PublicKey;
class PublicKeyDefaultTypeInternal;
extern PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
class SigningInput;
class SigningInputDefaultTypeInternal;
extern SigningInputDefaultTypeInternal _SigningInput_default_instance_;
class SigningOutput;
class SigningOutputDefaultTypeInternal;
extern SigningOutputDefaultTypeInternal _SigningOutput_default_instance_;
class Stake;
class StakeDefaultTypeInternal;
extern StakeDefaultTypeInternal _Stake_default_instance_;
class Transfer;
class TransferDefaultTypeInternal;
extern TransferDefaultTypeInternal _Transfer_default_instance_;
}  // namespace Proto
}  // namespace NEAR
}  // namespace TW
PROTOBUF_NAMESPACE_OPEN
template<> ::TW::NEAR::Proto::AccessKey* Arena::CreateMaybeMessage<::TW::NEAR::Proto::AccessKey>(Arena*);
template<> ::TW::NEAR::Proto::Action* Arena::CreateMaybeMessage<::TW::NEAR::Proto::Action>(Arena*);
template<> ::TW::NEAR::Proto::AddKey* Arena::CreateMaybeMessage<::TW::NEAR::Proto::AddKey>(Arena*);
template<> ::TW::NEAR::Proto::CreateAccount* Arena::CreateMaybeMessage<::TW::NEAR::Proto::CreateAccount>(Arena*);
template<> ::TW::NEAR::Proto::DeleteAccount* Arena::CreateMaybeMessage<::TW::NEAR::Proto::DeleteAccount>(Arena*);
template<> ::TW::NEAR::Proto::DeleteKey* Arena::CreateMaybeMessage<::TW::NEAR::Proto::DeleteKey>(Arena*);
template<> ::TW::NEAR::Proto::DeployContract* Arena::CreateMaybeMessage<::TW::NEAR::Proto::DeployContract>(Arena*);
template<> ::TW::NEAR::Proto::FullAccessPermission* Arena::CreateMaybeMessage<::TW::NEAR::Proto::FullAccessPermission>(Arena*);
template<> ::TW::NEAR::Proto::FunctionCall* Arena::CreateMaybeMessage<::TW::NEAR::Proto::FunctionCall>(Arena*);
template<> ::TW::NEAR::Proto::FunctionCallPermission* Arena::CreateMaybeMessage<::TW::NEAR::Proto::FunctionCallPermission>(Arena*);
template<> ::TW::NEAR::Proto::PublicKey* Arena::CreateMaybeMessage<::TW::NEAR::Proto::PublicKey>(Arena*);
template<> ::TW::NEAR::Proto::SigningInput* Arena::CreateMaybeMessage<::TW::NEAR::Proto::SigningInput>(Arena*);
template<> ::TW::NEAR::Proto::SigningOutput* Arena::CreateMaybeMessage<::TW::NEAR::Proto::SigningOutput>(Arena*);
template<> ::TW::NEAR::Proto::Stake* Arena::CreateMaybeMessage<::TW::NEAR::Proto::Stake>(Arena*);
template<> ::TW::NEAR::Proto::Transfer* Arena::CreateMaybeMessage<::TW::NEAR::Proto::Transfer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace TW {
namespace NEAR {
namespace Proto {

// ===================================================================

class PublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.PublicKey) */ {
 public:
  inline PublicKey() : PublicKey(nullptr) {}
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);
  PublicKey(PublicKey&& from) noexcept
    : PublicKey() {
    *this = ::std::move(from);
  }

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublicKey& operator=(PublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PublicKey& default_instance();

  static inline const PublicKey* internal_default_instance() {
    return reinterpret_cast<const PublicKey*>(
               &_PublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PublicKey& a, PublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(PublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublicKey* New() const final {
    return CreateMaybeMessage<PublicKey>(nullptr);
  }

  PublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublicKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.PublicKey";
  }
  protected:
  explicit PublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyTypeFieldNumber = 1,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // uint32 key_type = 1;
  void clear_key_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_type() const;
  void set_key_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_type() const;
  void _internal_set_key_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.PublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class FunctionCallPermission PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.FunctionCallPermission) */ {
 public:
  inline FunctionCallPermission() : FunctionCallPermission(nullptr) {}
  virtual ~FunctionCallPermission();

  FunctionCallPermission(const FunctionCallPermission& from);
  FunctionCallPermission(FunctionCallPermission&& from) noexcept
    : FunctionCallPermission() {
    *this = ::std::move(from);
  }

  inline FunctionCallPermission& operator=(const FunctionCallPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCallPermission& operator=(FunctionCallPermission&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FunctionCallPermission& default_instance();

  static inline const FunctionCallPermission* internal_default_instance() {
    return reinterpret_cast<const FunctionCallPermission*>(
               &_FunctionCallPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FunctionCallPermission& a, FunctionCallPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCallPermission* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCallPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionCallPermission* New() const final {
    return CreateMaybeMessage<FunctionCallPermission>(nullptr);
  }

  FunctionCallPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCallPermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FunctionCallPermission& from);
  void MergeFrom(const FunctionCallPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionCallPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.FunctionCallPermission";
  }
  protected:
  explicit FunctionCallPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowanceFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
  };
  // bytes allowance = 1;
  void clear_allowance();
  const std::string& allowance() const;
  void set_allowance(const std::string& value);
  void set_allowance(std::string&& value);
  void set_allowance(const char* value);
  void set_allowance(const void* value, size_t size);
  std::string* mutable_allowance();
  std::string* release_allowance();
  void set_allocated_allowance(std::string* allowance);
  private:
  const std::string& _internal_allowance() const;
  void _internal_set_allowance(const std::string& value);
  std::string* _internal_mutable_allowance();
  public:

  // string receiver_id = 2;
  void clear_receiver_id();
  const std::string& receiver_id() const;
  void set_receiver_id(const std::string& value);
  void set_receiver_id(std::string&& value);
  void set_receiver_id(const char* value);
  void set_receiver_id(const char* value, size_t size);
  std::string* mutable_receiver_id();
  std::string* release_receiver_id();
  void set_allocated_receiver_id(std::string* receiver_id);
  private:
  const std::string& _internal_receiver_id() const;
  void _internal_set_receiver_id(const std::string& value);
  std::string* _internal_mutable_receiver_id();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.FunctionCallPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allowance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class FullAccessPermission PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.FullAccessPermission) */ {
 public:
  inline FullAccessPermission() : FullAccessPermission(nullptr) {}
  virtual ~FullAccessPermission();

  FullAccessPermission(const FullAccessPermission& from);
  FullAccessPermission(FullAccessPermission&& from) noexcept
    : FullAccessPermission() {
    *this = ::std::move(from);
  }

  inline FullAccessPermission& operator=(const FullAccessPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline FullAccessPermission& operator=(FullAccessPermission&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FullAccessPermission& default_instance();

  static inline const FullAccessPermission* internal_default_instance() {
    return reinterpret_cast<const FullAccessPermission*>(
               &_FullAccessPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FullAccessPermission& a, FullAccessPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(FullAccessPermission* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FullAccessPermission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FullAccessPermission* New() const final {
    return CreateMaybeMessage<FullAccessPermission>(nullptr);
  }

  FullAccessPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FullAccessPermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FullAccessPermission& from);
  void MergeFrom(const FullAccessPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FullAccessPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.FullAccessPermission";
  }
  protected:
  explicit FullAccessPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.FullAccessPermission)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class AccessKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.AccessKey) */ {
 public:
  inline AccessKey() : AccessKey(nullptr) {}
  virtual ~AccessKey();

  AccessKey(const AccessKey& from);
  AccessKey(AccessKey&& from) noexcept
    : AccessKey() {
    *this = ::std::move(from);
  }

  inline AccessKey& operator=(const AccessKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccessKey& operator=(AccessKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccessKey& default_instance();

  enum PermissionCase {
    kFunctionCall = 2,
    kFullAccess = 3,
    PERMISSION_NOT_SET = 0,
  };

  static inline const AccessKey* internal_default_instance() {
    return reinterpret_cast<const AccessKey*>(
               &_AccessKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccessKey& a, AccessKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AccessKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccessKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccessKey* New() const final {
    return CreateMaybeMessage<AccessKey>(nullptr);
  }

  AccessKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccessKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccessKey& from);
  void MergeFrom(const AccessKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccessKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.AccessKey";
  }
  protected:
  explicit AccessKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kFunctionCallFieldNumber = 2,
    kFullAccessFieldNumber = 3,
  };
  // uint64 nonce = 1;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .TW.NEAR.Proto.FunctionCallPermission function_call = 2;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;
  public:
  void clear_function_call();
  const ::TW::NEAR::Proto::FunctionCallPermission& function_call() const;
  ::TW::NEAR::Proto::FunctionCallPermission* release_function_call();
  ::TW::NEAR::Proto::FunctionCallPermission* mutable_function_call();
  void set_allocated_function_call(::TW::NEAR::Proto::FunctionCallPermission* function_call);
  private:
  const ::TW::NEAR::Proto::FunctionCallPermission& _internal_function_call() const;
  ::TW::NEAR::Proto::FunctionCallPermission* _internal_mutable_function_call();
  public:
  void unsafe_arena_set_allocated_function_call(
      ::TW::NEAR::Proto::FunctionCallPermission* function_call);
  ::TW::NEAR::Proto::FunctionCallPermission* unsafe_arena_release_function_call();

  // .TW.NEAR.Proto.FullAccessPermission full_access = 3;
  bool has_full_access() const;
  private:
  bool _internal_has_full_access() const;
  public:
  void clear_full_access();
  const ::TW::NEAR::Proto::FullAccessPermission& full_access() const;
  ::TW::NEAR::Proto::FullAccessPermission* release_full_access();
  ::TW::NEAR::Proto::FullAccessPermission* mutable_full_access();
  void set_allocated_full_access(::TW::NEAR::Proto::FullAccessPermission* full_access);
  private:
  const ::TW::NEAR::Proto::FullAccessPermission& _internal_full_access() const;
  ::TW::NEAR::Proto::FullAccessPermission* _internal_mutable_full_access();
  public:
  void unsafe_arena_set_allocated_full_access(
      ::TW::NEAR::Proto::FullAccessPermission* full_access);
  ::TW::NEAR::Proto::FullAccessPermission* unsafe_arena_release_full_access();

  void clear_permission();
  PermissionCase permission_case() const;
  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.AccessKey)
 private:
  class _Internal;
  void set_has_function_call();
  void set_has_full_access();

  inline bool has_permission() const;
  inline void clear_has_permission();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  union PermissionUnion {
    PermissionUnion() {}
    ::TW::NEAR::Proto::FunctionCallPermission* function_call_;
    ::TW::NEAR::Proto::FullAccessPermission* full_access_;
  } permission_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class CreateAccount PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.CreateAccount) */ {
 public:
  inline CreateAccount() : CreateAccount(nullptr) {}
  virtual ~CreateAccount();

  CreateAccount(const CreateAccount& from);
  CreateAccount(CreateAccount&& from) noexcept
    : CreateAccount() {
    *this = ::std::move(from);
  }

  inline CreateAccount& operator=(const CreateAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccount& operator=(CreateAccount&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateAccount& default_instance();

  static inline const CreateAccount* internal_default_instance() {
    return reinterpret_cast<const CreateAccount*>(
               &_CreateAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateAccount& a, CreateAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccount* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateAccount* New() const final {
    return CreateMaybeMessage<CreateAccount>(nullptr);
  }

  CreateAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateAccount& from);
  void MergeFrom(const CreateAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.CreateAccount";
  }
  protected:
  explicit CreateAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.CreateAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class DeployContract PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.DeployContract) */ {
 public:
  inline DeployContract() : DeployContract(nullptr) {}
  virtual ~DeployContract();

  DeployContract(const DeployContract& from);
  DeployContract(DeployContract&& from) noexcept
    : DeployContract() {
    *this = ::std::move(from);
  }

  inline DeployContract& operator=(const DeployContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeployContract& operator=(DeployContract&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeployContract& default_instance();

  static inline const DeployContract* internal_default_instance() {
    return reinterpret_cast<const DeployContract*>(
               &_DeployContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DeployContract& a, DeployContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DeployContract* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeployContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeployContract* New() const final {
    return CreateMaybeMessage<DeployContract>(nullptr);
  }

  DeployContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeployContract>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeployContract& from);
  void MergeFrom(const DeployContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeployContract* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.DeployContract";
  }
  protected:
  explicit DeployContract(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // bytes code = 1;
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const void* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.DeployContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class FunctionCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.FunctionCall) */ {
 public:
  inline FunctionCall() : FunctionCall(nullptr) {}
  virtual ~FunctionCall();

  FunctionCall(const FunctionCall& from);
  FunctionCall(FunctionCall&& from) noexcept
    : FunctionCall() {
    *this = ::std::move(from);
  }

  inline FunctionCall& operator=(const FunctionCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionCall& operator=(FunctionCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FunctionCall& default_instance();

  static inline const FunctionCall* internal_default_instance() {
    return reinterpret_cast<const FunctionCall*>(
               &_FunctionCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FunctionCall& a, FunctionCall& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FunctionCall* New() const final {
    return CreateMaybeMessage<FunctionCall>(nullptr);
  }

  FunctionCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FunctionCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FunctionCall& from);
  void MergeFrom(const FunctionCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.FunctionCall";
  }
  protected:
  explicit FunctionCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMethodNameFieldNumber = 1,
    kArgsFieldNumber = 2,
    kDepositFieldNumber = 4,
    kGasFieldNumber = 3,
  };
  // bytes method_name = 1;
  void clear_method_name();
  const std::string& method_name() const;
  void set_method_name(const std::string& value);
  void set_method_name(std::string&& value);
  void set_method_name(const char* value);
  void set_method_name(const void* value, size_t size);
  std::string* mutable_method_name();
  std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);
  private:
  const std::string& _internal_method_name() const;
  void _internal_set_method_name(const std::string& value);
  std::string* _internal_mutable_method_name();
  public:

  // bytes args = 2;
  void clear_args();
  const std::string& args() const;
  void set_args(const std::string& value);
  void set_args(std::string&& value);
  void set_args(const char* value);
  void set_args(const void* value, size_t size);
  std::string* mutable_args();
  std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // bytes deposit = 4;
  void clear_deposit();
  const std::string& deposit() const;
  void set_deposit(const std::string& value);
  void set_deposit(std::string&& value);
  void set_deposit(const char* value);
  void set_deposit(const void* value, size_t size);
  std::string* mutable_deposit();
  std::string* release_deposit();
  void set_allocated_deposit(std::string* deposit);
  private:
  const std::string& _internal_deposit() const;
  void _internal_set_deposit(const std::string& value);
  std::string* _internal_mutable_deposit();
  public:

  // uint64 gas = 3;
  void clear_gas();
  ::PROTOBUF_NAMESPACE_ID::uint64 gas() const;
  void set_gas(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_gas() const;
  void _internal_set_gas(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.FunctionCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deposit_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gas_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class Transfer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.Transfer) */ {
 public:
  inline Transfer() : Transfer(nullptr) {}
  virtual ~Transfer();

  Transfer(const Transfer& from);
  Transfer(Transfer&& from) noexcept
    : Transfer() {
    *this = ::std::move(from);
  }

  inline Transfer& operator=(const Transfer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transfer& operator=(Transfer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transfer& default_instance();

  static inline const Transfer* internal_default_instance() {
    return reinterpret_cast<const Transfer*>(
               &_Transfer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Transfer& a, Transfer& b) {
    a.Swap(&b);
  }
  inline void Swap(Transfer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transfer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transfer* New() const final {
    return CreateMaybeMessage<Transfer>(nullptr);
  }

  Transfer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transfer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transfer& from);
  void MergeFrom(const Transfer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transfer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.Transfer";
  }
  protected:
  explicit Transfer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepositFieldNumber = 1,
  };
  // bytes deposit = 1;
  void clear_deposit();
  const std::string& deposit() const;
  void set_deposit(const std::string& value);
  void set_deposit(std::string&& value);
  void set_deposit(const char* value);
  void set_deposit(const void* value, size_t size);
  std::string* mutable_deposit();
  std::string* release_deposit();
  void set_allocated_deposit(std::string* deposit);
  private:
  const std::string& _internal_deposit() const;
  void _internal_set_deposit(const std::string& value);
  std::string* _internal_mutable_deposit();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.Transfer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deposit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class Stake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.Stake) */ {
 public:
  inline Stake() : Stake(nullptr) {}
  virtual ~Stake();

  Stake(const Stake& from);
  Stake(Stake&& from) noexcept
    : Stake() {
    *this = ::std::move(from);
  }

  inline Stake& operator=(const Stake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stake& operator=(Stake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Stake& default_instance();

  static inline const Stake* internal_default_instance() {
    return reinterpret_cast<const Stake*>(
               &_Stake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Stake& a, Stake& b) {
    a.Swap(&b);
  }
  inline void Swap(Stake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stake* New() const final {
    return CreateMaybeMessage<Stake>(nullptr);
  }

  Stake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Stake& from);
  void MergeFrom(const Stake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.Stake";
  }
  protected:
  explicit Stake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStakeFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
  };
  // bytes stake = 1;
  void clear_stake();
  const std::string& stake() const;
  void set_stake(const std::string& value);
  void set_stake(std::string&& value);
  void set_stake(const char* value);
  void set_stake(const void* value, size_t size);
  std::string* mutable_stake();
  std::string* release_stake();
  void set_allocated_stake(std::string* stake);
  private:
  const std::string& _internal_stake() const;
  void _internal_set_stake(const std::string& value);
  std::string* _internal_mutable_stake();
  public:

  // string public_key = 2;
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.Stake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stake_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class AddKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.AddKey) */ {
 public:
  inline AddKey() : AddKey(nullptr) {}
  virtual ~AddKey();

  AddKey(const AddKey& from);
  AddKey(AddKey&& from) noexcept
    : AddKey() {
    *this = ::std::move(from);
  }

  inline AddKey& operator=(const AddKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddKey& operator=(AddKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddKey& default_instance();

  static inline const AddKey* internal_default_instance() {
    return reinterpret_cast<const AddKey*>(
               &_AddKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddKey& a, AddKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AddKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddKey* New() const final {
    return CreateMaybeMessage<AddKey>(nullptr);
  }

  AddKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddKey& from);
  void MergeFrom(const AddKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.AddKey";
  }
  protected:
  explicit AddKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kAccessKeyFieldNumber = 2,
  };
  // .TW.NEAR.Proto.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::TW::NEAR::Proto::PublicKey& public_key() const;
  ::TW::NEAR::Proto::PublicKey* release_public_key();
  ::TW::NEAR::Proto::PublicKey* mutable_public_key();
  void set_allocated_public_key(::TW::NEAR::Proto::PublicKey* public_key);
  private:
  const ::TW::NEAR::Proto::PublicKey& _internal_public_key() const;
  ::TW::NEAR::Proto::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::TW::NEAR::Proto::PublicKey* public_key);
  ::TW::NEAR::Proto::PublicKey* unsafe_arena_release_public_key();

  // .TW.NEAR.Proto.AccessKey access_key = 2;
  bool has_access_key() const;
  private:
  bool _internal_has_access_key() const;
  public:
  void clear_access_key();
  const ::TW::NEAR::Proto::AccessKey& access_key() const;
  ::TW::NEAR::Proto::AccessKey* release_access_key();
  ::TW::NEAR::Proto::AccessKey* mutable_access_key();
  void set_allocated_access_key(::TW::NEAR::Proto::AccessKey* access_key);
  private:
  const ::TW::NEAR::Proto::AccessKey& _internal_access_key() const;
  ::TW::NEAR::Proto::AccessKey* _internal_mutable_access_key();
  public:
  void unsafe_arena_set_allocated_access_key(
      ::TW::NEAR::Proto::AccessKey* access_key);
  ::TW::NEAR::Proto::AccessKey* unsafe_arena_release_access_key();

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.AddKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::NEAR::Proto::PublicKey* public_key_;
  ::TW::NEAR::Proto::AccessKey* access_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class DeleteKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.DeleteKey) */ {
 public:
  inline DeleteKey() : DeleteKey(nullptr) {}
  virtual ~DeleteKey();

  DeleteKey(const DeleteKey& from);
  DeleteKey(DeleteKey&& from) noexcept
    : DeleteKey() {
    *this = ::std::move(from);
  }

  inline DeleteKey& operator=(const DeleteKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteKey& operator=(DeleteKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteKey& default_instance();

  static inline const DeleteKey* internal_default_instance() {
    return reinterpret_cast<const DeleteKey*>(
               &_DeleteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DeleteKey& a, DeleteKey& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteKey* New() const final {
    return CreateMaybeMessage<DeleteKey>(nullptr);
  }

  DeleteKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteKey& from);
  void MergeFrom(const DeleteKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.DeleteKey";
  }
  protected:
  explicit DeleteKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
  };
  // .TW.NEAR.Proto.PublicKey public_key = 1;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const ::TW::NEAR::Proto::PublicKey& public_key() const;
  ::TW::NEAR::Proto::PublicKey* release_public_key();
  ::TW::NEAR::Proto::PublicKey* mutable_public_key();
  void set_allocated_public_key(::TW::NEAR::Proto::PublicKey* public_key);
  private:
  const ::TW::NEAR::Proto::PublicKey& _internal_public_key() const;
  ::TW::NEAR::Proto::PublicKey* _internal_mutable_public_key();
  public:
  void unsafe_arena_set_allocated_public_key(
      ::TW::NEAR::Proto::PublicKey* public_key);
  ::TW::NEAR::Proto::PublicKey* unsafe_arena_release_public_key();

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.DeleteKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TW::NEAR::Proto::PublicKey* public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccount PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.DeleteAccount) */ {
 public:
  inline DeleteAccount() : DeleteAccount(nullptr) {}
  virtual ~DeleteAccount();

  DeleteAccount(const DeleteAccount& from);
  DeleteAccount(DeleteAccount&& from) noexcept
    : DeleteAccount() {
    *this = ::std::move(from);
  }

  inline DeleteAccount& operator=(const DeleteAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccount& operator=(DeleteAccount&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteAccount& default_instance();

  static inline const DeleteAccount* internal_default_instance() {
    return reinterpret_cast<const DeleteAccount*>(
               &_DeleteAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteAccount& a, DeleteAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccount* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteAccount* New() const final {
    return CreateMaybeMessage<DeleteAccount>(nullptr);
  }

  DeleteAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteAccount>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteAccount& from);
  void MergeFrom(const DeleteAccount& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.DeleteAccount";
  }
  protected:
  explicit DeleteAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeneficiaryIdFieldNumber = 1,
  };
  // string beneficiary_id = 1;
  void clear_beneficiary_id();
  const std::string& beneficiary_id() const;
  void set_beneficiary_id(const std::string& value);
  void set_beneficiary_id(std::string&& value);
  void set_beneficiary_id(const char* value);
  void set_beneficiary_id(const char* value, size_t size);
  std::string* mutable_beneficiary_id();
  std::string* release_beneficiary_id();
  void set_allocated_beneficiary_id(std::string* beneficiary_id);
  private:
  const std::string& _internal_beneficiary_id() const;
  void _internal_set_beneficiary_id(const std::string& value);
  std::string* _internal_mutable_beneficiary_id();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.DeleteAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beneficiary_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class Action PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  virtual ~Action();

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Action& default_instance();

  enum PayloadCase {
    kCreateAccount = 1,
    kDeployContract = 2,
    kFunctionCall = 3,
    kTransfer = 4,
    kStake = 5,
    kAddKey = 6,
    kDeleteKey = 7,
    kDeleteAccount = 8,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(nullptr);
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateAccountFieldNumber = 1,
    kDeployContractFieldNumber = 2,
    kFunctionCallFieldNumber = 3,
    kTransferFieldNumber = 4,
    kStakeFieldNumber = 5,
    kAddKeyFieldNumber = 6,
    kDeleteKeyFieldNumber = 7,
    kDeleteAccountFieldNumber = 8,
  };
  // .TW.NEAR.Proto.CreateAccount create_account = 1;
  bool has_create_account() const;
  private:
  bool _internal_has_create_account() const;
  public:
  void clear_create_account();
  const ::TW::NEAR::Proto::CreateAccount& create_account() const;
  ::TW::NEAR::Proto::CreateAccount* release_create_account();
  ::TW::NEAR::Proto::CreateAccount* mutable_create_account();
  void set_allocated_create_account(::TW::NEAR::Proto::CreateAccount* create_account);
  private:
  const ::TW::NEAR::Proto::CreateAccount& _internal_create_account() const;
  ::TW::NEAR::Proto::CreateAccount* _internal_mutable_create_account();
  public:
  void unsafe_arena_set_allocated_create_account(
      ::TW::NEAR::Proto::CreateAccount* create_account);
  ::TW::NEAR::Proto::CreateAccount* unsafe_arena_release_create_account();

  // .TW.NEAR.Proto.DeployContract deploy_contract = 2;
  bool has_deploy_contract() const;
  private:
  bool _internal_has_deploy_contract() const;
  public:
  void clear_deploy_contract();
  const ::TW::NEAR::Proto::DeployContract& deploy_contract() const;
  ::TW::NEAR::Proto::DeployContract* release_deploy_contract();
  ::TW::NEAR::Proto::DeployContract* mutable_deploy_contract();
  void set_allocated_deploy_contract(::TW::NEAR::Proto::DeployContract* deploy_contract);
  private:
  const ::TW::NEAR::Proto::DeployContract& _internal_deploy_contract() const;
  ::TW::NEAR::Proto::DeployContract* _internal_mutable_deploy_contract();
  public:
  void unsafe_arena_set_allocated_deploy_contract(
      ::TW::NEAR::Proto::DeployContract* deploy_contract);
  ::TW::NEAR::Proto::DeployContract* unsafe_arena_release_deploy_contract();

  // .TW.NEAR.Proto.FunctionCall function_call = 3;
  bool has_function_call() const;
  private:
  bool _internal_has_function_call() const;
  public:
  void clear_function_call();
  const ::TW::NEAR::Proto::FunctionCall& function_call() const;
  ::TW::NEAR::Proto::FunctionCall* release_function_call();
  ::TW::NEAR::Proto::FunctionCall* mutable_function_call();
  void set_allocated_function_call(::TW::NEAR::Proto::FunctionCall* function_call);
  private:
  const ::TW::NEAR::Proto::FunctionCall& _internal_function_call() const;
  ::TW::NEAR::Proto::FunctionCall* _internal_mutable_function_call();
  public:
  void unsafe_arena_set_allocated_function_call(
      ::TW::NEAR::Proto::FunctionCall* function_call);
  ::TW::NEAR::Proto::FunctionCall* unsafe_arena_release_function_call();

  // .TW.NEAR.Proto.Transfer transfer = 4;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::TW::NEAR::Proto::Transfer& transfer() const;
  ::TW::NEAR::Proto::Transfer* release_transfer();
  ::TW::NEAR::Proto::Transfer* mutable_transfer();
  void set_allocated_transfer(::TW::NEAR::Proto::Transfer* transfer);
  private:
  const ::TW::NEAR::Proto::Transfer& _internal_transfer() const;
  ::TW::NEAR::Proto::Transfer* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::TW::NEAR::Proto::Transfer* transfer);
  ::TW::NEAR::Proto::Transfer* unsafe_arena_release_transfer();

  // .TW.NEAR.Proto.Stake stake = 5;
  bool has_stake() const;
  private:
  bool _internal_has_stake() const;
  public:
  void clear_stake();
  const ::TW::NEAR::Proto::Stake& stake() const;
  ::TW::NEAR::Proto::Stake* release_stake();
  ::TW::NEAR::Proto::Stake* mutable_stake();
  void set_allocated_stake(::TW::NEAR::Proto::Stake* stake);
  private:
  const ::TW::NEAR::Proto::Stake& _internal_stake() const;
  ::TW::NEAR::Proto::Stake* _internal_mutable_stake();
  public:
  void unsafe_arena_set_allocated_stake(
      ::TW::NEAR::Proto::Stake* stake);
  ::TW::NEAR::Proto::Stake* unsafe_arena_release_stake();

  // .TW.NEAR.Proto.AddKey add_key = 6;
  bool has_add_key() const;
  private:
  bool _internal_has_add_key() const;
  public:
  void clear_add_key();
  const ::TW::NEAR::Proto::AddKey& add_key() const;
  ::TW::NEAR::Proto::AddKey* release_add_key();
  ::TW::NEAR::Proto::AddKey* mutable_add_key();
  void set_allocated_add_key(::TW::NEAR::Proto::AddKey* add_key);
  private:
  const ::TW::NEAR::Proto::AddKey& _internal_add_key() const;
  ::TW::NEAR::Proto::AddKey* _internal_mutable_add_key();
  public:
  void unsafe_arena_set_allocated_add_key(
      ::TW::NEAR::Proto::AddKey* add_key);
  ::TW::NEAR::Proto::AddKey* unsafe_arena_release_add_key();

  // .TW.NEAR.Proto.DeleteKey delete_key = 7;
  bool has_delete_key() const;
  private:
  bool _internal_has_delete_key() const;
  public:
  void clear_delete_key();
  const ::TW::NEAR::Proto::DeleteKey& delete_key() const;
  ::TW::NEAR::Proto::DeleteKey* release_delete_key();
  ::TW::NEAR::Proto::DeleteKey* mutable_delete_key();
  void set_allocated_delete_key(::TW::NEAR::Proto::DeleteKey* delete_key);
  private:
  const ::TW::NEAR::Proto::DeleteKey& _internal_delete_key() const;
  ::TW::NEAR::Proto::DeleteKey* _internal_mutable_delete_key();
  public:
  void unsafe_arena_set_allocated_delete_key(
      ::TW::NEAR::Proto::DeleteKey* delete_key);
  ::TW::NEAR::Proto::DeleteKey* unsafe_arena_release_delete_key();

  // .TW.NEAR.Proto.DeleteAccount delete_account = 8;
  bool has_delete_account() const;
  private:
  bool _internal_has_delete_account() const;
  public:
  void clear_delete_account();
  const ::TW::NEAR::Proto::DeleteAccount& delete_account() const;
  ::TW::NEAR::Proto::DeleteAccount* release_delete_account();
  ::TW::NEAR::Proto::DeleteAccount* mutable_delete_account();
  void set_allocated_delete_account(::TW::NEAR::Proto::DeleteAccount* delete_account);
  private:
  const ::TW::NEAR::Proto::DeleteAccount& _internal_delete_account() const;
  ::TW::NEAR::Proto::DeleteAccount* _internal_mutable_delete_account();
  public:
  void unsafe_arena_set_allocated_delete_account(
      ::TW::NEAR::Proto::DeleteAccount* delete_account);
  ::TW::NEAR::Proto::DeleteAccount* unsafe_arena_release_delete_account();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.Action)
 private:
  class _Internal;
  void set_has_create_account();
  void set_has_deploy_contract();
  void set_has_function_call();
  void set_has_transfer();
  void set_has_stake();
  void set_has_add_key();
  void set_has_delete_key();
  void set_has_delete_account();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union PayloadUnion {
    PayloadUnion() {}
    ::TW::NEAR::Proto::CreateAccount* create_account_;
    ::TW::NEAR::Proto::DeployContract* deploy_contract_;
    ::TW::NEAR::Proto::FunctionCall* function_call_;
    ::TW::NEAR::Proto::Transfer* transfer_;
    ::TW::NEAR::Proto::Stake* stake_;
    ::TW::NEAR::Proto::AddKey* add_key_;
    ::TW::NEAR::Proto::DeleteKey* delete_key_;
    ::TW::NEAR::Proto::DeleteAccount* delete_account_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class SigningInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.SigningInput) */ {
 public:
  inline SigningInput() : SigningInput(nullptr) {}
  virtual ~SigningInput();

  SigningInput(const SigningInput& from);
  SigningInput(SigningInput&& from) noexcept
    : SigningInput() {
    *this = ::std::move(from);
  }

  inline SigningInput& operator=(const SigningInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningInput& operator=(SigningInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SigningInput& default_instance();

  static inline const SigningInput* internal_default_instance() {
    return reinterpret_cast<const SigningInput*>(
               &_SigningInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SigningInput& a, SigningInput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SigningInput* New() const final {
    return CreateMaybeMessage<SigningInput>(nullptr);
  }

  SigningInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SigningInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SigningInput& from);
  void MergeFrom(const SigningInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.SigningInput";
  }
  protected:
  explicit SigningInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 5,
    kSignerIdFieldNumber = 1,
    kReceiverIdFieldNumber = 3,
    kBlockHashFieldNumber = 4,
    kPrivateKeyFieldNumber = 6,
    kNonceFieldNumber = 2,
  };
  // repeated .TW.NEAR.Proto.Action actions = 5;
  int actions_size() const;
  private:
  int _internal_actions_size() const;
  public:
  void clear_actions();
  ::TW::NEAR::Proto::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::NEAR::Proto::Action >*
      mutable_actions();
  private:
  const ::TW::NEAR::Proto::Action& _internal_actions(int index) const;
  ::TW::NEAR::Proto::Action* _internal_add_actions();
  public:
  const ::TW::NEAR::Proto::Action& actions(int index) const;
  ::TW::NEAR::Proto::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::NEAR::Proto::Action >&
      actions() const;

  // string signer_id = 1;
  void clear_signer_id();
  const std::string& signer_id() const;
  void set_signer_id(const std::string& value);
  void set_signer_id(std::string&& value);
  void set_signer_id(const char* value);
  void set_signer_id(const char* value, size_t size);
  std::string* mutable_signer_id();
  std::string* release_signer_id();
  void set_allocated_signer_id(std::string* signer_id);
  private:
  const std::string& _internal_signer_id() const;
  void _internal_set_signer_id(const std::string& value);
  std::string* _internal_mutable_signer_id();
  public:

  // string receiver_id = 3;
  void clear_receiver_id();
  const std::string& receiver_id() const;
  void set_receiver_id(const std::string& value);
  void set_receiver_id(std::string&& value);
  void set_receiver_id(const char* value);
  void set_receiver_id(const char* value, size_t size);
  std::string* mutable_receiver_id();
  std::string* release_receiver_id();
  void set_allocated_receiver_id(std::string* receiver_id);
  private:
  const std::string& _internal_receiver_id() const;
  void _internal_set_receiver_id(const std::string& value);
  std::string* _internal_mutable_receiver_id();
  public:

  // bytes block_hash = 4;
  void clear_block_hash();
  const std::string& block_hash() const;
  void set_block_hash(const std::string& value);
  void set_block_hash(std::string&& value);
  void set_block_hash(const char* value);
  void set_block_hash(const void* value, size_t size);
  std::string* mutable_block_hash();
  std::string* release_block_hash();
  void set_allocated_block_hash(std::string* block_hash);
  private:
  const std::string& _internal_block_hash() const;
  void _internal_set_block_hash(const std::string& value);
  std::string* _internal_mutable_block_hash();
  public:

  // bytes private_key = 6;
  void clear_private_key();
  const std::string& private_key() const;
  void set_private_key(const std::string& value);
  void set_private_key(std::string&& value);
  void set_private_key(const char* value);
  void set_private_key(const void* value, size_t size);
  std::string* mutable_private_key();
  std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // uint64 nonce = 2;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.SigningInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::NEAR::Proto::Action > actions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// -------------------------------------------------------------------

class SigningOutput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TW.NEAR.Proto.SigningOutput) */ {
 public:
  inline SigningOutput() : SigningOutput(nullptr) {}
  virtual ~SigningOutput();

  SigningOutput(const SigningOutput& from);
  SigningOutput(SigningOutput&& from) noexcept
    : SigningOutput() {
    *this = ::std::move(from);
  }

  inline SigningOutput& operator=(const SigningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline SigningOutput& operator=(SigningOutput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SigningOutput& default_instance();

  static inline const SigningOutput* internal_default_instance() {
    return reinterpret_cast<const SigningOutput*>(
               &_SigningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SigningOutput& a, SigningOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(SigningOutput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SigningOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SigningOutput* New() const final {
    return CreateMaybeMessage<SigningOutput>(nullptr);
  }

  SigningOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SigningOutput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SigningOutput& from);
  void MergeFrom(const SigningOutput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SigningOutput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TW.NEAR.Proto.SigningOutput";
  }
  protected:
  explicit SigningOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_NEAR_2eproto);
    return ::descriptor_table_NEAR_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedTransactionFieldNumber = 1,
  };
  // bytes signed_transaction = 1;
  void clear_signed_transaction();
  const std::string& signed_transaction() const;
  void set_signed_transaction(const std::string& value);
  void set_signed_transaction(std::string&& value);
  void set_signed_transaction(const char* value);
  void set_signed_transaction(const void* value, size_t size);
  std::string* mutable_signed_transaction();
  std::string* release_signed_transaction();
  void set_allocated_signed_transaction(std::string* signed_transaction);
  private:
  const std::string& _internal_signed_transaction() const;
  void _internal_set_signed_transaction(const std::string& value);
  std::string* _internal_mutable_signed_transaction();
  public:

  // @@protoc_insertion_point(class_scope:TW.NEAR.Proto.SigningOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signed_transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_NEAR_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PublicKey

// uint32 key_type = 1;
inline void PublicKey::clear_key_type() {
  key_type_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicKey::_internal_key_type() const {
  return key_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PublicKey::key_type() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.PublicKey.key_type)
  return _internal_key_type();
}
inline void PublicKey::_internal_set_key_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  key_type_ = value;
}
inline void PublicKey::set_key_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.PublicKey.key_type)
}

// bytes data = 2;
inline void PublicKey::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& PublicKey::data() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.PublicKey.data)
  return _internal_data();
}
inline void PublicKey::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.PublicKey.data)
}
inline std::string* PublicKey::mutable_data() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.PublicKey.data)
  return _internal_mutable_data();
}
inline const std::string& PublicKey::_internal_data() const {
  return data_.Get();
}
inline void PublicKey::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PublicKey::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.PublicKey.data)
}
inline void PublicKey::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.PublicKey.data)
}
inline void PublicKey::set_data(const void* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.PublicKey.data)
}
inline std::string* PublicKey::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PublicKey::release_data() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.PublicKey.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PublicKey::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.PublicKey.data)
}

// -------------------------------------------------------------------

// FunctionCallPermission

// bytes allowance = 1;
inline void FunctionCallPermission::clear_allowance() {
  allowance_.ClearToEmpty();
}
inline const std::string& FunctionCallPermission::allowance() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCallPermission.allowance)
  return _internal_allowance();
}
inline void FunctionCallPermission::set_allowance(const std::string& value) {
  _internal_set_allowance(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCallPermission.allowance)
}
inline std::string* FunctionCallPermission::mutable_allowance() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.FunctionCallPermission.allowance)
  return _internal_mutable_allowance();
}
inline const std::string& FunctionCallPermission::_internal_allowance() const {
  return allowance_.Get();
}
inline void FunctionCallPermission::_internal_set_allowance(const std::string& value) {
  
  allowance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FunctionCallPermission::set_allowance(std::string&& value) {
  
  allowance_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.FunctionCallPermission.allowance)
}
inline void FunctionCallPermission::set_allowance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  allowance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.FunctionCallPermission.allowance)
}
inline void FunctionCallPermission::set_allowance(const void* value,
    size_t size) {
  
  allowance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.FunctionCallPermission.allowance)
}
inline std::string* FunctionCallPermission::_internal_mutable_allowance() {
  
  return allowance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FunctionCallPermission::release_allowance() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.FunctionCallPermission.allowance)
  return allowance_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCallPermission::set_allocated_allowance(std::string* allowance) {
  if (allowance != nullptr) {
    
  } else {
    
  }
  allowance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), allowance,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.FunctionCallPermission.allowance)
}

// string receiver_id = 2;
inline void FunctionCallPermission::clear_receiver_id() {
  receiver_id_.ClearToEmpty();
}
inline const std::string& FunctionCallPermission::receiver_id() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
  return _internal_receiver_id();
}
inline void FunctionCallPermission::set_receiver_id(const std::string& value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
}
inline std::string* FunctionCallPermission::mutable_receiver_id() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
  return _internal_mutable_receiver_id();
}
inline const std::string& FunctionCallPermission::_internal_receiver_id() const {
  return receiver_id_.Get();
}
inline void FunctionCallPermission::_internal_set_receiver_id(const std::string& value) {
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FunctionCallPermission::set_receiver_id(std::string&& value) {
  
  receiver_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
}
inline void FunctionCallPermission::set_receiver_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
}
inline void FunctionCallPermission::set_receiver_id(const char* value,
    size_t size) {
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
}
inline std::string* FunctionCallPermission::_internal_mutable_receiver_id() {
  
  return receiver_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FunctionCallPermission::release_receiver_id() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
  return receiver_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCallPermission::set_allocated_receiver_id(std::string* receiver_id) {
  if (receiver_id != nullptr) {
    
  } else {
    
  }
  receiver_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.FunctionCallPermission.receiver_id)
}

// -------------------------------------------------------------------

// FullAccessPermission

// -------------------------------------------------------------------

// AccessKey

// uint64 nonce = 1;
inline void AccessKey::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AccessKey::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AccessKey::nonce() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.AccessKey.nonce)
  return _internal_nonce();
}
inline void AccessKey::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void AccessKey::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.AccessKey.nonce)
}

// .TW.NEAR.Proto.FunctionCallPermission function_call = 2;
inline bool AccessKey::_internal_has_function_call() const {
  return permission_case() == kFunctionCall;
}
inline bool AccessKey::has_function_call() const {
  return _internal_has_function_call();
}
inline void AccessKey::set_has_function_call() {
  _oneof_case_[0] = kFunctionCall;
}
inline void AccessKey::clear_function_call() {
  if (_internal_has_function_call()) {
    if (GetArena() == nullptr) {
      delete permission_.function_call_;
    }
    clear_has_permission();
  }
}
inline ::TW::NEAR::Proto::FunctionCallPermission* AccessKey::release_function_call() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.AccessKey.function_call)
  if (_internal_has_function_call()) {
    clear_has_permission();
      ::TW::NEAR::Proto::FunctionCallPermission* temp = permission_.function_call_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    permission_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::FunctionCallPermission& AccessKey::_internal_function_call() const {
  return _internal_has_function_call()
      ? *permission_.function_call_
      : reinterpret_cast< ::TW::NEAR::Proto::FunctionCallPermission&>(::TW::NEAR::Proto::_FunctionCallPermission_default_instance_);
}
inline const ::TW::NEAR::Proto::FunctionCallPermission& AccessKey::function_call() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.AccessKey.function_call)
  return _internal_function_call();
}
inline ::TW::NEAR::Proto::FunctionCallPermission* AccessKey::unsafe_arena_release_function_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.AccessKey.function_call)
  if (_internal_has_function_call()) {
    clear_has_permission();
    ::TW::NEAR::Proto::FunctionCallPermission* temp = permission_.function_call_;
    permission_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AccessKey::unsafe_arena_set_allocated_function_call(::TW::NEAR::Proto::FunctionCallPermission* function_call) {
  clear_permission();
  if (function_call) {
    set_has_function_call();
    permission_.function_call_ = function_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.AccessKey.function_call)
}
inline ::TW::NEAR::Proto::FunctionCallPermission* AccessKey::_internal_mutable_function_call() {
  if (!_internal_has_function_call()) {
    clear_permission();
    set_has_function_call();
    permission_.function_call_ = CreateMaybeMessage< ::TW::NEAR::Proto::FunctionCallPermission >(GetArena());
  }
  return permission_.function_call_;
}
inline ::TW::NEAR::Proto::FunctionCallPermission* AccessKey::mutable_function_call() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.AccessKey.function_call)
  return _internal_mutable_function_call();
}

// .TW.NEAR.Proto.FullAccessPermission full_access = 3;
inline bool AccessKey::_internal_has_full_access() const {
  return permission_case() == kFullAccess;
}
inline bool AccessKey::has_full_access() const {
  return _internal_has_full_access();
}
inline void AccessKey::set_has_full_access() {
  _oneof_case_[0] = kFullAccess;
}
inline void AccessKey::clear_full_access() {
  if (_internal_has_full_access()) {
    if (GetArena() == nullptr) {
      delete permission_.full_access_;
    }
    clear_has_permission();
  }
}
inline ::TW::NEAR::Proto::FullAccessPermission* AccessKey::release_full_access() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.AccessKey.full_access)
  if (_internal_has_full_access()) {
    clear_has_permission();
      ::TW::NEAR::Proto::FullAccessPermission* temp = permission_.full_access_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    permission_.full_access_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::FullAccessPermission& AccessKey::_internal_full_access() const {
  return _internal_has_full_access()
      ? *permission_.full_access_
      : reinterpret_cast< ::TW::NEAR::Proto::FullAccessPermission&>(::TW::NEAR::Proto::_FullAccessPermission_default_instance_);
}
inline const ::TW::NEAR::Proto::FullAccessPermission& AccessKey::full_access() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.AccessKey.full_access)
  return _internal_full_access();
}
inline ::TW::NEAR::Proto::FullAccessPermission* AccessKey::unsafe_arena_release_full_access() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.AccessKey.full_access)
  if (_internal_has_full_access()) {
    clear_has_permission();
    ::TW::NEAR::Proto::FullAccessPermission* temp = permission_.full_access_;
    permission_.full_access_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AccessKey::unsafe_arena_set_allocated_full_access(::TW::NEAR::Proto::FullAccessPermission* full_access) {
  clear_permission();
  if (full_access) {
    set_has_full_access();
    permission_.full_access_ = full_access;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.AccessKey.full_access)
}
inline ::TW::NEAR::Proto::FullAccessPermission* AccessKey::_internal_mutable_full_access() {
  if (!_internal_has_full_access()) {
    clear_permission();
    set_has_full_access();
    permission_.full_access_ = CreateMaybeMessage< ::TW::NEAR::Proto::FullAccessPermission >(GetArena());
  }
  return permission_.full_access_;
}
inline ::TW::NEAR::Proto::FullAccessPermission* AccessKey::mutable_full_access() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.AccessKey.full_access)
  return _internal_mutable_full_access();
}

inline bool AccessKey::has_permission() const {
  return permission_case() != PERMISSION_NOT_SET;
}
inline void AccessKey::clear_has_permission() {
  _oneof_case_[0] = PERMISSION_NOT_SET;
}
inline AccessKey::PermissionCase AccessKey::permission_case() const {
  return AccessKey::PermissionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateAccount

// -------------------------------------------------------------------

// DeployContract

// bytes code = 1;
inline void DeployContract::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& DeployContract::code() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.DeployContract.code)
  return _internal_code();
}
inline void DeployContract::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.DeployContract.code)
}
inline std::string* DeployContract::mutable_code() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.DeployContract.code)
  return _internal_mutable_code();
}
inline const std::string& DeployContract::_internal_code() const {
  return code_.Get();
}
inline void DeployContract::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DeployContract::set_code(std::string&& value) {
  
  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.DeployContract.code)
}
inline void DeployContract::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.DeployContract.code)
}
inline void DeployContract::set_code(const void* value,
    size_t size) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.DeployContract.code)
}
inline std::string* DeployContract::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DeployContract::release_code() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.DeployContract.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeployContract::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.DeployContract.code)
}

// -------------------------------------------------------------------

// FunctionCall

// bytes method_name = 1;
inline void FunctionCall::clear_method_name() {
  method_name_.ClearToEmpty();
}
inline const std::string& FunctionCall::method_name() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCall.method_name)
  return _internal_method_name();
}
inline void FunctionCall::set_method_name(const std::string& value) {
  _internal_set_method_name(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCall.method_name)
}
inline std::string* FunctionCall::mutable_method_name() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.FunctionCall.method_name)
  return _internal_mutable_method_name();
}
inline const std::string& FunctionCall::_internal_method_name() const {
  return method_name_.Get();
}
inline void FunctionCall::_internal_set_method_name(const std::string& value) {
  
  method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FunctionCall::set_method_name(std::string&& value) {
  
  method_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.FunctionCall.method_name)
}
inline void FunctionCall::set_method_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.FunctionCall.method_name)
}
inline void FunctionCall::set_method_name(const void* value,
    size_t size) {
  
  method_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.FunctionCall.method_name)
}
inline std::string* FunctionCall::_internal_mutable_method_name() {
  
  return method_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FunctionCall::release_method_name() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.FunctionCall.method_name)
  return method_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCall::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    
  } else {
    
  }
  method_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.FunctionCall.method_name)
}

// bytes args = 2;
inline void FunctionCall::clear_args() {
  args_.ClearToEmpty();
}
inline const std::string& FunctionCall::args() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCall.args)
  return _internal_args();
}
inline void FunctionCall::set_args(const std::string& value) {
  _internal_set_args(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCall.args)
}
inline std::string* FunctionCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.FunctionCall.args)
  return _internal_mutable_args();
}
inline const std::string& FunctionCall::_internal_args() const {
  return args_.Get();
}
inline void FunctionCall::_internal_set_args(const std::string& value) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FunctionCall::set_args(std::string&& value) {
  
  args_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.FunctionCall.args)
}
inline void FunctionCall::set_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.FunctionCall.args)
}
inline void FunctionCall::set_args(const void* value,
    size_t size) {
  
  args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.FunctionCall.args)
}
inline std::string* FunctionCall::_internal_mutable_args() {
  
  return args_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FunctionCall::release_args() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.FunctionCall.args)
  return args_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCall::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  args_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), args,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.FunctionCall.args)
}

// uint64 gas = 3;
inline void FunctionCall::clear_gas() {
  gas_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FunctionCall::_internal_gas() const {
  return gas_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FunctionCall::gas() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCall.gas)
  return _internal_gas();
}
inline void FunctionCall::_internal_set_gas(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  gas_ = value;
}
inline void FunctionCall::set_gas(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCall.gas)
}

// bytes deposit = 4;
inline void FunctionCall::clear_deposit() {
  deposit_.ClearToEmpty();
}
inline const std::string& FunctionCall::deposit() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.FunctionCall.deposit)
  return _internal_deposit();
}
inline void FunctionCall::set_deposit(const std::string& value) {
  _internal_set_deposit(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.FunctionCall.deposit)
}
inline std::string* FunctionCall::mutable_deposit() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.FunctionCall.deposit)
  return _internal_mutable_deposit();
}
inline const std::string& FunctionCall::_internal_deposit() const {
  return deposit_.Get();
}
inline void FunctionCall::_internal_set_deposit(const std::string& value) {
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FunctionCall::set_deposit(std::string&& value) {
  
  deposit_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.FunctionCall.deposit)
}
inline void FunctionCall::set_deposit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.FunctionCall.deposit)
}
inline void FunctionCall::set_deposit(const void* value,
    size_t size) {
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.FunctionCall.deposit)
}
inline std::string* FunctionCall::_internal_mutable_deposit() {
  
  return deposit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FunctionCall::release_deposit() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.FunctionCall.deposit)
  return deposit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FunctionCall::set_allocated_deposit(std::string* deposit) {
  if (deposit != nullptr) {
    
  } else {
    
  }
  deposit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deposit,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.FunctionCall.deposit)
}

// -------------------------------------------------------------------

// Transfer

// bytes deposit = 1;
inline void Transfer::clear_deposit() {
  deposit_.ClearToEmpty();
}
inline const std::string& Transfer::deposit() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Transfer.deposit)
  return _internal_deposit();
}
inline void Transfer::set_deposit(const std::string& value) {
  _internal_set_deposit(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.Transfer.deposit)
}
inline std::string* Transfer::mutable_deposit() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Transfer.deposit)
  return _internal_mutable_deposit();
}
inline const std::string& Transfer::_internal_deposit() const {
  return deposit_.Get();
}
inline void Transfer::_internal_set_deposit(const std::string& value) {
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Transfer::set_deposit(std::string&& value) {
  
  deposit_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.Transfer.deposit)
}
inline void Transfer::set_deposit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.Transfer.deposit)
}
inline void Transfer::set_deposit(const void* value,
    size_t size) {
  
  deposit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.Transfer.deposit)
}
inline std::string* Transfer::_internal_mutable_deposit() {
  
  return deposit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Transfer::release_deposit() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Transfer.deposit)
  return deposit_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Transfer::set_allocated_deposit(std::string* deposit) {
  if (deposit != nullptr) {
    
  } else {
    
  }
  deposit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deposit,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.Transfer.deposit)
}

// -------------------------------------------------------------------

// Stake

// bytes stake = 1;
inline void Stake::clear_stake() {
  stake_.ClearToEmpty();
}
inline const std::string& Stake::stake() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Stake.stake)
  return _internal_stake();
}
inline void Stake::set_stake(const std::string& value) {
  _internal_set_stake(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.Stake.stake)
}
inline std::string* Stake::mutable_stake() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Stake.stake)
  return _internal_mutable_stake();
}
inline const std::string& Stake::_internal_stake() const {
  return stake_.Get();
}
inline void Stake::_internal_set_stake(const std::string& value) {
  
  stake_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stake::set_stake(std::string&& value) {
  
  stake_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.Stake.stake)
}
inline void Stake::set_stake(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stake_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.Stake.stake)
}
inline void Stake::set_stake(const void* value,
    size_t size) {
  
  stake_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.Stake.stake)
}
inline std::string* Stake::_internal_mutable_stake() {
  
  return stake_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stake::release_stake() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Stake.stake)
  return stake_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stake::set_allocated_stake(std::string* stake) {
  if (stake != nullptr) {
    
  } else {
    
  }
  stake_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stake,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.Stake.stake)
}

// string public_key = 2;
inline void Stake::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& Stake::public_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Stake.public_key)
  return _internal_public_key();
}
inline void Stake::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.Stake.public_key)
}
inline std::string* Stake::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Stake.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& Stake::_internal_public_key() const {
  return public_key_.Get();
}
inline void Stake::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stake::set_public_key(std::string&& value) {
  
  public_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.Stake.public_key)
}
inline void Stake::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.Stake.public_key)
}
inline void Stake::set_public_key(const char* value,
    size_t size) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.Stake.public_key)
}
inline std::string* Stake::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stake::release_public_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Stake.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stake::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.Stake.public_key)
}

// -------------------------------------------------------------------

// AddKey

// .TW.NEAR.Proto.PublicKey public_key = 1;
inline bool AddKey::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool AddKey::has_public_key() const {
  return _internal_has_public_key();
}
inline void AddKey::clear_public_key() {
  if (GetArena() == nullptr && public_key_ != nullptr) {
    delete public_key_;
  }
  public_key_ = nullptr;
}
inline const ::TW::NEAR::Proto::PublicKey& AddKey::_internal_public_key() const {
  const ::TW::NEAR::Proto::PublicKey* p = public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::NEAR::Proto::PublicKey&>(
      ::TW::NEAR::Proto::_PublicKey_default_instance_);
}
inline const ::TW::NEAR::Proto::PublicKey& AddKey::public_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.AddKey.public_key)
  return _internal_public_key();
}
inline void AddKey::unsafe_arena_set_allocated_public_key(
    ::TW::NEAR::Proto::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.AddKey.public_key)
}
inline ::TW::NEAR::Proto::PublicKey* AddKey::release_public_key() {
  
  ::TW::NEAR::Proto::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TW::NEAR::Proto::PublicKey* AddKey::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.AddKey.public_key)
  
  ::TW::NEAR::Proto::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::TW::NEAR::Proto::PublicKey* AddKey::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::NEAR::Proto::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::TW::NEAR::Proto::PublicKey* AddKey::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.AddKey.public_key)
  return _internal_mutable_public_key();
}
inline void AddKey::set_allocated_public_key(::TW::NEAR::Proto::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.AddKey.public_key)
}

// .TW.NEAR.Proto.AccessKey access_key = 2;
inline bool AddKey::_internal_has_access_key() const {
  return this != internal_default_instance() && access_key_ != nullptr;
}
inline bool AddKey::has_access_key() const {
  return _internal_has_access_key();
}
inline void AddKey::clear_access_key() {
  if (GetArena() == nullptr && access_key_ != nullptr) {
    delete access_key_;
  }
  access_key_ = nullptr;
}
inline const ::TW::NEAR::Proto::AccessKey& AddKey::_internal_access_key() const {
  const ::TW::NEAR::Proto::AccessKey* p = access_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::NEAR::Proto::AccessKey&>(
      ::TW::NEAR::Proto::_AccessKey_default_instance_);
}
inline const ::TW::NEAR::Proto::AccessKey& AddKey::access_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.AddKey.access_key)
  return _internal_access_key();
}
inline void AddKey::unsafe_arena_set_allocated_access_key(
    ::TW::NEAR::Proto::AccessKey* access_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(access_key_);
  }
  access_key_ = access_key;
  if (access_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.AddKey.access_key)
}
inline ::TW::NEAR::Proto::AccessKey* AddKey::release_access_key() {
  
  ::TW::NEAR::Proto::AccessKey* temp = access_key_;
  access_key_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TW::NEAR::Proto::AccessKey* AddKey::unsafe_arena_release_access_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.AddKey.access_key)
  
  ::TW::NEAR::Proto::AccessKey* temp = access_key_;
  access_key_ = nullptr;
  return temp;
}
inline ::TW::NEAR::Proto::AccessKey* AddKey::_internal_mutable_access_key() {
  
  if (access_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::NEAR::Proto::AccessKey>(GetArena());
    access_key_ = p;
  }
  return access_key_;
}
inline ::TW::NEAR::Proto::AccessKey* AddKey::mutable_access_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.AddKey.access_key)
  return _internal_mutable_access_key();
}
inline void AddKey::set_allocated_access_key(::TW::NEAR::Proto::AccessKey* access_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete access_key_;
  }
  if (access_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(access_key);
    if (message_arena != submessage_arena) {
      access_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, access_key, submessage_arena);
    }
    
  } else {
    
  }
  access_key_ = access_key;
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.AddKey.access_key)
}

// -------------------------------------------------------------------

// DeleteKey

// .TW.NEAR.Proto.PublicKey public_key = 1;
inline bool DeleteKey::_internal_has_public_key() const {
  return this != internal_default_instance() && public_key_ != nullptr;
}
inline bool DeleteKey::has_public_key() const {
  return _internal_has_public_key();
}
inline void DeleteKey::clear_public_key() {
  if (GetArena() == nullptr && public_key_ != nullptr) {
    delete public_key_;
  }
  public_key_ = nullptr;
}
inline const ::TW::NEAR::Proto::PublicKey& DeleteKey::_internal_public_key() const {
  const ::TW::NEAR::Proto::PublicKey* p = public_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::TW::NEAR::Proto::PublicKey&>(
      ::TW::NEAR::Proto::_PublicKey_default_instance_);
}
inline const ::TW::NEAR::Proto::PublicKey& DeleteKey::public_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.DeleteKey.public_key)
  return _internal_public_key();
}
inline void DeleteKey::unsafe_arena_set_allocated_public_key(
    ::TW::NEAR::Proto::PublicKey* public_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_key_);
  }
  public_key_ = public_key;
  if (public_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.DeleteKey.public_key)
}
inline ::TW::NEAR::Proto::PublicKey* DeleteKey::release_public_key() {
  
  ::TW::NEAR::Proto::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::TW::NEAR::Proto::PublicKey* DeleteKey::unsafe_arena_release_public_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.DeleteKey.public_key)
  
  ::TW::NEAR::Proto::PublicKey* temp = public_key_;
  public_key_ = nullptr;
  return temp;
}
inline ::TW::NEAR::Proto::PublicKey* DeleteKey::_internal_mutable_public_key() {
  
  if (public_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::TW::NEAR::Proto::PublicKey>(GetArena());
    public_key_ = p;
  }
  return public_key_;
}
inline ::TW::NEAR::Proto::PublicKey* DeleteKey::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.DeleteKey.public_key)
  return _internal_mutable_public_key();
}
inline void DeleteKey::set_allocated_public_key(::TW::NEAR::Proto::PublicKey* public_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete public_key_;
  }
  if (public_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(public_key);
    if (message_arena != submessage_arena) {
      public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_key, submessage_arena);
    }
    
  } else {
    
  }
  public_key_ = public_key;
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.DeleteKey.public_key)
}

// -------------------------------------------------------------------

// DeleteAccount

// string beneficiary_id = 1;
inline void DeleteAccount::clear_beneficiary_id() {
  beneficiary_id_.ClearToEmpty();
}
inline const std::string& DeleteAccount::beneficiary_id() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
  return _internal_beneficiary_id();
}
inline void DeleteAccount::set_beneficiary_id(const std::string& value) {
  _internal_set_beneficiary_id(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
}
inline std::string* DeleteAccount::mutable_beneficiary_id() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
  return _internal_mutable_beneficiary_id();
}
inline const std::string& DeleteAccount::_internal_beneficiary_id() const {
  return beneficiary_id_.Get();
}
inline void DeleteAccount::_internal_set_beneficiary_id(const std::string& value) {
  
  beneficiary_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DeleteAccount::set_beneficiary_id(std::string&& value) {
  
  beneficiary_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
}
inline void DeleteAccount::set_beneficiary_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  beneficiary_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
}
inline void DeleteAccount::set_beneficiary_id(const char* value,
    size_t size) {
  
  beneficiary_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
}
inline std::string* DeleteAccount::_internal_mutable_beneficiary_id() {
  
  return beneficiary_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DeleteAccount::release_beneficiary_id() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
  return beneficiary_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteAccount::set_allocated_beneficiary_id(std::string* beneficiary_id) {
  if (beneficiary_id != nullptr) {
    
  } else {
    
  }
  beneficiary_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), beneficiary_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.DeleteAccount.beneficiary_id)
}

// -------------------------------------------------------------------

// Action

// .TW.NEAR.Proto.CreateAccount create_account = 1;
inline bool Action::_internal_has_create_account() const {
  return payload_case() == kCreateAccount;
}
inline bool Action::has_create_account() const {
  return _internal_has_create_account();
}
inline void Action::set_has_create_account() {
  _oneof_case_[0] = kCreateAccount;
}
inline void Action::clear_create_account() {
  if (_internal_has_create_account()) {
    if (GetArena() == nullptr) {
      delete payload_.create_account_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::CreateAccount* Action::release_create_account() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.create_account)
  if (_internal_has_create_account()) {
    clear_has_payload();
      ::TW::NEAR::Proto::CreateAccount* temp = payload_.create_account_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::CreateAccount& Action::_internal_create_account() const {
  return _internal_has_create_account()
      ? *payload_.create_account_
      : reinterpret_cast< ::TW::NEAR::Proto::CreateAccount&>(::TW::NEAR::Proto::_CreateAccount_default_instance_);
}
inline const ::TW::NEAR::Proto::CreateAccount& Action::create_account() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.create_account)
  return _internal_create_account();
}
inline ::TW::NEAR::Proto::CreateAccount* Action::unsafe_arena_release_create_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.create_account)
  if (_internal_has_create_account()) {
    clear_has_payload();
    ::TW::NEAR::Proto::CreateAccount* temp = payload_.create_account_;
    payload_.create_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_create_account(::TW::NEAR::Proto::CreateAccount* create_account) {
  clear_payload();
  if (create_account) {
    set_has_create_account();
    payload_.create_account_ = create_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.create_account)
}
inline ::TW::NEAR::Proto::CreateAccount* Action::_internal_mutable_create_account() {
  if (!_internal_has_create_account()) {
    clear_payload();
    set_has_create_account();
    payload_.create_account_ = CreateMaybeMessage< ::TW::NEAR::Proto::CreateAccount >(GetArena());
  }
  return payload_.create_account_;
}
inline ::TW::NEAR::Proto::CreateAccount* Action::mutable_create_account() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.create_account)
  return _internal_mutable_create_account();
}

// .TW.NEAR.Proto.DeployContract deploy_contract = 2;
inline bool Action::_internal_has_deploy_contract() const {
  return payload_case() == kDeployContract;
}
inline bool Action::has_deploy_contract() const {
  return _internal_has_deploy_contract();
}
inline void Action::set_has_deploy_contract() {
  _oneof_case_[0] = kDeployContract;
}
inline void Action::clear_deploy_contract() {
  if (_internal_has_deploy_contract()) {
    if (GetArena() == nullptr) {
      delete payload_.deploy_contract_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::DeployContract* Action::release_deploy_contract() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.deploy_contract)
  if (_internal_has_deploy_contract()) {
    clear_has_payload();
      ::TW::NEAR::Proto::DeployContract* temp = payload_.deploy_contract_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.deploy_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::DeployContract& Action::_internal_deploy_contract() const {
  return _internal_has_deploy_contract()
      ? *payload_.deploy_contract_
      : reinterpret_cast< ::TW::NEAR::Proto::DeployContract&>(::TW::NEAR::Proto::_DeployContract_default_instance_);
}
inline const ::TW::NEAR::Proto::DeployContract& Action::deploy_contract() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.deploy_contract)
  return _internal_deploy_contract();
}
inline ::TW::NEAR::Proto::DeployContract* Action::unsafe_arena_release_deploy_contract() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.deploy_contract)
  if (_internal_has_deploy_contract()) {
    clear_has_payload();
    ::TW::NEAR::Proto::DeployContract* temp = payload_.deploy_contract_;
    payload_.deploy_contract_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_deploy_contract(::TW::NEAR::Proto::DeployContract* deploy_contract) {
  clear_payload();
  if (deploy_contract) {
    set_has_deploy_contract();
    payload_.deploy_contract_ = deploy_contract;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.deploy_contract)
}
inline ::TW::NEAR::Proto::DeployContract* Action::_internal_mutable_deploy_contract() {
  if (!_internal_has_deploy_contract()) {
    clear_payload();
    set_has_deploy_contract();
    payload_.deploy_contract_ = CreateMaybeMessage< ::TW::NEAR::Proto::DeployContract >(GetArena());
  }
  return payload_.deploy_contract_;
}
inline ::TW::NEAR::Proto::DeployContract* Action::mutable_deploy_contract() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.deploy_contract)
  return _internal_mutable_deploy_contract();
}

// .TW.NEAR.Proto.FunctionCall function_call = 3;
inline bool Action::_internal_has_function_call() const {
  return payload_case() == kFunctionCall;
}
inline bool Action::has_function_call() const {
  return _internal_has_function_call();
}
inline void Action::set_has_function_call() {
  _oneof_case_[0] = kFunctionCall;
}
inline void Action::clear_function_call() {
  if (_internal_has_function_call()) {
    if (GetArena() == nullptr) {
      delete payload_.function_call_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::FunctionCall* Action::release_function_call() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.function_call)
  if (_internal_has_function_call()) {
    clear_has_payload();
      ::TW::NEAR::Proto::FunctionCall* temp = payload_.function_call_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::FunctionCall& Action::_internal_function_call() const {
  return _internal_has_function_call()
      ? *payload_.function_call_
      : reinterpret_cast< ::TW::NEAR::Proto::FunctionCall&>(::TW::NEAR::Proto::_FunctionCall_default_instance_);
}
inline const ::TW::NEAR::Proto::FunctionCall& Action::function_call() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.function_call)
  return _internal_function_call();
}
inline ::TW::NEAR::Proto::FunctionCall* Action::unsafe_arena_release_function_call() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.function_call)
  if (_internal_has_function_call()) {
    clear_has_payload();
    ::TW::NEAR::Proto::FunctionCall* temp = payload_.function_call_;
    payload_.function_call_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_function_call(::TW::NEAR::Proto::FunctionCall* function_call) {
  clear_payload();
  if (function_call) {
    set_has_function_call();
    payload_.function_call_ = function_call;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.function_call)
}
inline ::TW::NEAR::Proto::FunctionCall* Action::_internal_mutable_function_call() {
  if (!_internal_has_function_call()) {
    clear_payload();
    set_has_function_call();
    payload_.function_call_ = CreateMaybeMessage< ::TW::NEAR::Proto::FunctionCall >(GetArena());
  }
  return payload_.function_call_;
}
inline ::TW::NEAR::Proto::FunctionCall* Action::mutable_function_call() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.function_call)
  return _internal_mutable_function_call();
}

// .TW.NEAR.Proto.Transfer transfer = 4;
inline bool Action::_internal_has_transfer() const {
  return payload_case() == kTransfer;
}
inline bool Action::has_transfer() const {
  return _internal_has_transfer();
}
inline void Action::set_has_transfer() {
  _oneof_case_[0] = kTransfer;
}
inline void Action::clear_transfer() {
  if (_internal_has_transfer()) {
    if (GetArena() == nullptr) {
      delete payload_.transfer_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::Transfer* Action::release_transfer() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.transfer)
  if (_internal_has_transfer()) {
    clear_has_payload();
      ::TW::NEAR::Proto::Transfer* temp = payload_.transfer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::Transfer& Action::_internal_transfer() const {
  return _internal_has_transfer()
      ? *payload_.transfer_
      : reinterpret_cast< ::TW::NEAR::Proto::Transfer&>(::TW::NEAR::Proto::_Transfer_default_instance_);
}
inline const ::TW::NEAR::Proto::Transfer& Action::transfer() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.transfer)
  return _internal_transfer();
}
inline ::TW::NEAR::Proto::Transfer* Action::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.transfer)
  if (_internal_has_transfer()) {
    clear_has_payload();
    ::TW::NEAR::Proto::Transfer* temp = payload_.transfer_;
    payload_.transfer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_transfer(::TW::NEAR::Proto::Transfer* transfer) {
  clear_payload();
  if (transfer) {
    set_has_transfer();
    payload_.transfer_ = transfer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.transfer)
}
inline ::TW::NEAR::Proto::Transfer* Action::_internal_mutable_transfer() {
  if (!_internal_has_transfer()) {
    clear_payload();
    set_has_transfer();
    payload_.transfer_ = CreateMaybeMessage< ::TW::NEAR::Proto::Transfer >(GetArena());
  }
  return payload_.transfer_;
}
inline ::TW::NEAR::Proto::Transfer* Action::mutable_transfer() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.transfer)
  return _internal_mutable_transfer();
}

// .TW.NEAR.Proto.Stake stake = 5;
inline bool Action::_internal_has_stake() const {
  return payload_case() == kStake;
}
inline bool Action::has_stake() const {
  return _internal_has_stake();
}
inline void Action::set_has_stake() {
  _oneof_case_[0] = kStake;
}
inline void Action::clear_stake() {
  if (_internal_has_stake()) {
    if (GetArena() == nullptr) {
      delete payload_.stake_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::Stake* Action::release_stake() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.stake)
  if (_internal_has_stake()) {
    clear_has_payload();
      ::TW::NEAR::Proto::Stake* temp = payload_.stake_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.stake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::Stake& Action::_internal_stake() const {
  return _internal_has_stake()
      ? *payload_.stake_
      : reinterpret_cast< ::TW::NEAR::Proto::Stake&>(::TW::NEAR::Proto::_Stake_default_instance_);
}
inline const ::TW::NEAR::Proto::Stake& Action::stake() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.stake)
  return _internal_stake();
}
inline ::TW::NEAR::Proto::Stake* Action::unsafe_arena_release_stake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.stake)
  if (_internal_has_stake()) {
    clear_has_payload();
    ::TW::NEAR::Proto::Stake* temp = payload_.stake_;
    payload_.stake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_stake(::TW::NEAR::Proto::Stake* stake) {
  clear_payload();
  if (stake) {
    set_has_stake();
    payload_.stake_ = stake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.stake)
}
inline ::TW::NEAR::Proto::Stake* Action::_internal_mutable_stake() {
  if (!_internal_has_stake()) {
    clear_payload();
    set_has_stake();
    payload_.stake_ = CreateMaybeMessage< ::TW::NEAR::Proto::Stake >(GetArena());
  }
  return payload_.stake_;
}
inline ::TW::NEAR::Proto::Stake* Action::mutable_stake() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.stake)
  return _internal_mutable_stake();
}

// .TW.NEAR.Proto.AddKey add_key = 6;
inline bool Action::_internal_has_add_key() const {
  return payload_case() == kAddKey;
}
inline bool Action::has_add_key() const {
  return _internal_has_add_key();
}
inline void Action::set_has_add_key() {
  _oneof_case_[0] = kAddKey;
}
inline void Action::clear_add_key() {
  if (_internal_has_add_key()) {
    if (GetArena() == nullptr) {
      delete payload_.add_key_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::AddKey* Action::release_add_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.add_key)
  if (_internal_has_add_key()) {
    clear_has_payload();
      ::TW::NEAR::Proto::AddKey* temp = payload_.add_key_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.add_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::AddKey& Action::_internal_add_key() const {
  return _internal_has_add_key()
      ? *payload_.add_key_
      : reinterpret_cast< ::TW::NEAR::Proto::AddKey&>(::TW::NEAR::Proto::_AddKey_default_instance_);
}
inline const ::TW::NEAR::Proto::AddKey& Action::add_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.add_key)
  return _internal_add_key();
}
inline ::TW::NEAR::Proto::AddKey* Action::unsafe_arena_release_add_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.add_key)
  if (_internal_has_add_key()) {
    clear_has_payload();
    ::TW::NEAR::Proto::AddKey* temp = payload_.add_key_;
    payload_.add_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_add_key(::TW::NEAR::Proto::AddKey* add_key) {
  clear_payload();
  if (add_key) {
    set_has_add_key();
    payload_.add_key_ = add_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.add_key)
}
inline ::TW::NEAR::Proto::AddKey* Action::_internal_mutable_add_key() {
  if (!_internal_has_add_key()) {
    clear_payload();
    set_has_add_key();
    payload_.add_key_ = CreateMaybeMessage< ::TW::NEAR::Proto::AddKey >(GetArena());
  }
  return payload_.add_key_;
}
inline ::TW::NEAR::Proto::AddKey* Action::mutable_add_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.add_key)
  return _internal_mutable_add_key();
}

// .TW.NEAR.Proto.DeleteKey delete_key = 7;
inline bool Action::_internal_has_delete_key() const {
  return payload_case() == kDeleteKey;
}
inline bool Action::has_delete_key() const {
  return _internal_has_delete_key();
}
inline void Action::set_has_delete_key() {
  _oneof_case_[0] = kDeleteKey;
}
inline void Action::clear_delete_key() {
  if (_internal_has_delete_key()) {
    if (GetArena() == nullptr) {
      delete payload_.delete_key_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::DeleteKey* Action::release_delete_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.delete_key)
  if (_internal_has_delete_key()) {
    clear_has_payload();
      ::TW::NEAR::Proto::DeleteKey* temp = payload_.delete_key_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::DeleteKey& Action::_internal_delete_key() const {
  return _internal_has_delete_key()
      ? *payload_.delete_key_
      : reinterpret_cast< ::TW::NEAR::Proto::DeleteKey&>(::TW::NEAR::Proto::_DeleteKey_default_instance_);
}
inline const ::TW::NEAR::Proto::DeleteKey& Action::delete_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.delete_key)
  return _internal_delete_key();
}
inline ::TW::NEAR::Proto::DeleteKey* Action::unsafe_arena_release_delete_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.delete_key)
  if (_internal_has_delete_key()) {
    clear_has_payload();
    ::TW::NEAR::Proto::DeleteKey* temp = payload_.delete_key_;
    payload_.delete_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_delete_key(::TW::NEAR::Proto::DeleteKey* delete_key) {
  clear_payload();
  if (delete_key) {
    set_has_delete_key();
    payload_.delete_key_ = delete_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.delete_key)
}
inline ::TW::NEAR::Proto::DeleteKey* Action::_internal_mutable_delete_key() {
  if (!_internal_has_delete_key()) {
    clear_payload();
    set_has_delete_key();
    payload_.delete_key_ = CreateMaybeMessage< ::TW::NEAR::Proto::DeleteKey >(GetArena());
  }
  return payload_.delete_key_;
}
inline ::TW::NEAR::Proto::DeleteKey* Action::mutable_delete_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.delete_key)
  return _internal_mutable_delete_key();
}

// .TW.NEAR.Proto.DeleteAccount delete_account = 8;
inline bool Action::_internal_has_delete_account() const {
  return payload_case() == kDeleteAccount;
}
inline bool Action::has_delete_account() const {
  return _internal_has_delete_account();
}
inline void Action::set_has_delete_account() {
  _oneof_case_[0] = kDeleteAccount;
}
inline void Action::clear_delete_account() {
  if (_internal_has_delete_account()) {
    if (GetArena() == nullptr) {
      delete payload_.delete_account_;
    }
    clear_has_payload();
  }
}
inline ::TW::NEAR::Proto::DeleteAccount* Action::release_delete_account() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.Action.delete_account)
  if (_internal_has_delete_account()) {
    clear_has_payload();
      ::TW::NEAR::Proto::DeleteAccount* temp = payload_.delete_account_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.delete_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TW::NEAR::Proto::DeleteAccount& Action::_internal_delete_account() const {
  return _internal_has_delete_account()
      ? *payload_.delete_account_
      : reinterpret_cast< ::TW::NEAR::Proto::DeleteAccount&>(::TW::NEAR::Proto::_DeleteAccount_default_instance_);
}
inline const ::TW::NEAR::Proto::DeleteAccount& Action::delete_account() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.Action.delete_account)
  return _internal_delete_account();
}
inline ::TW::NEAR::Proto::DeleteAccount* Action::unsafe_arena_release_delete_account() {
  // @@protoc_insertion_point(field_unsafe_arena_release:TW.NEAR.Proto.Action.delete_account)
  if (_internal_has_delete_account()) {
    clear_has_payload();
    ::TW::NEAR::Proto::DeleteAccount* temp = payload_.delete_account_;
    payload_.delete_account_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Action::unsafe_arena_set_allocated_delete_account(::TW::NEAR::Proto::DeleteAccount* delete_account) {
  clear_payload();
  if (delete_account) {
    set_has_delete_account();
    payload_.delete_account_ = delete_account;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TW.NEAR.Proto.Action.delete_account)
}
inline ::TW::NEAR::Proto::DeleteAccount* Action::_internal_mutable_delete_account() {
  if (!_internal_has_delete_account()) {
    clear_payload();
    set_has_delete_account();
    payload_.delete_account_ = CreateMaybeMessage< ::TW::NEAR::Proto::DeleteAccount >(GetArena());
  }
  return payload_.delete_account_;
}
inline ::TW::NEAR::Proto::DeleteAccount* Action::mutable_delete_account() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.Action.delete_account)
  return _internal_mutable_delete_account();
}

inline bool Action::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Action::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Action::PayloadCase Action::payload_case() const {
  return Action::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SigningInput

// string signer_id = 1;
inline void SigningInput::clear_signer_id() {
  signer_id_.ClearToEmpty();
}
inline const std::string& SigningInput::signer_id() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.signer_id)
  return _internal_signer_id();
}
inline void SigningInput::set_signer_id(const std::string& value) {
  _internal_set_signer_id(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningInput.signer_id)
}
inline std::string* SigningInput::mutable_signer_id() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningInput.signer_id)
  return _internal_mutable_signer_id();
}
inline const std::string& SigningInput::_internal_signer_id() const {
  return signer_id_.Get();
}
inline void SigningInput::_internal_set_signer_id(const std::string& value) {
  
  signer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SigningInput::set_signer_id(std::string&& value) {
  
  signer_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.SigningInput.signer_id)
}
inline void SigningInput::set_signer_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.SigningInput.signer_id)
}
inline void SigningInput::set_signer_id(const char* value,
    size_t size) {
  
  signer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.SigningInput.signer_id)
}
inline std::string* SigningInput::_internal_mutable_signer_id() {
  
  return signer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SigningInput::release_signer_id() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.SigningInput.signer_id)
  return signer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SigningInput::set_allocated_signer_id(std::string* signer_id) {
  if (signer_id != nullptr) {
    
  } else {
    
  }
  signer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signer_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.SigningInput.signer_id)
}

// uint64 nonce = 2;
inline void SigningInput::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SigningInput::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SigningInput::nonce() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.nonce)
  return _internal_nonce();
}
inline void SigningInput::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  nonce_ = value;
}
inline void SigningInput::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningInput.nonce)
}

// string receiver_id = 3;
inline void SigningInput::clear_receiver_id() {
  receiver_id_.ClearToEmpty();
}
inline const std::string& SigningInput::receiver_id() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.receiver_id)
  return _internal_receiver_id();
}
inline void SigningInput::set_receiver_id(const std::string& value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningInput.receiver_id)
}
inline std::string* SigningInput::mutable_receiver_id() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningInput.receiver_id)
  return _internal_mutable_receiver_id();
}
inline const std::string& SigningInput::_internal_receiver_id() const {
  return receiver_id_.Get();
}
inline void SigningInput::_internal_set_receiver_id(const std::string& value) {
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SigningInput::set_receiver_id(std::string&& value) {
  
  receiver_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.SigningInput.receiver_id)
}
inline void SigningInput::set_receiver_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.SigningInput.receiver_id)
}
inline void SigningInput::set_receiver_id(const char* value,
    size_t size) {
  
  receiver_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.SigningInput.receiver_id)
}
inline std::string* SigningInput::_internal_mutable_receiver_id() {
  
  return receiver_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SigningInput::release_receiver_id() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.SigningInput.receiver_id)
  return receiver_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SigningInput::set_allocated_receiver_id(std::string* receiver_id) {
  if (receiver_id != nullptr) {
    
  } else {
    
  }
  receiver_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.SigningInput.receiver_id)
}

// bytes block_hash = 4;
inline void SigningInput::clear_block_hash() {
  block_hash_.ClearToEmpty();
}
inline const std::string& SigningInput::block_hash() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.block_hash)
  return _internal_block_hash();
}
inline void SigningInput::set_block_hash(const std::string& value) {
  _internal_set_block_hash(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningInput.block_hash)
}
inline std::string* SigningInput::mutable_block_hash() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningInput.block_hash)
  return _internal_mutable_block_hash();
}
inline const std::string& SigningInput::_internal_block_hash() const {
  return block_hash_.Get();
}
inline void SigningInput::_internal_set_block_hash(const std::string& value) {
  
  block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SigningInput::set_block_hash(std::string&& value) {
  
  block_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.SigningInput.block_hash)
}
inline void SigningInput::set_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.SigningInput.block_hash)
}
inline void SigningInput::set_block_hash(const void* value,
    size_t size) {
  
  block_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.SigningInput.block_hash)
}
inline std::string* SigningInput::_internal_mutable_block_hash() {
  
  return block_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SigningInput::release_block_hash() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.SigningInput.block_hash)
  return block_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SigningInput::set_allocated_block_hash(std::string* block_hash) {
  if (block_hash != nullptr) {
    
  } else {
    
  }
  block_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.SigningInput.block_hash)
}

// repeated .TW.NEAR.Proto.Action actions = 5;
inline int SigningInput::_internal_actions_size() const {
  return actions_.size();
}
inline int SigningInput::actions_size() const {
  return _internal_actions_size();
}
inline void SigningInput::clear_actions() {
  actions_.Clear();
}
inline ::TW::NEAR::Proto::Action* SigningInput::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningInput.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::NEAR::Proto::Action >*
SigningInput::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:TW.NEAR.Proto.SigningInput.actions)
  return &actions_;
}
inline const ::TW::NEAR::Proto::Action& SigningInput::_internal_actions(int index) const {
  return actions_.Get(index);
}
inline const ::TW::NEAR::Proto::Action& SigningInput::actions(int index) const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.actions)
  return _internal_actions(index);
}
inline ::TW::NEAR::Proto::Action* SigningInput::_internal_add_actions() {
  return actions_.Add();
}
inline ::TW::NEAR::Proto::Action* SigningInput::add_actions() {
  // @@protoc_insertion_point(field_add:TW.NEAR.Proto.SigningInput.actions)
  return _internal_add_actions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TW::NEAR::Proto::Action >&
SigningInput::actions() const {
  // @@protoc_insertion_point(field_list:TW.NEAR.Proto.SigningInput.actions)
  return actions_;
}

// bytes private_key = 6;
inline void SigningInput::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& SigningInput::private_key() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningInput.private_key)
  return _internal_private_key();
}
inline void SigningInput::set_private_key(const std::string& value) {
  _internal_set_private_key(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningInput.private_key)
  return _internal_mutable_private_key();
}
inline const std::string& SigningInput::_internal_private_key() const {
  return private_key_.Get();
}
inline void SigningInput::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SigningInput::set_private_key(std::string&& value) {
  
  private_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.SigningInput.private_key)
}
inline void SigningInput::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.SigningInput.private_key)
}
inline void SigningInput::set_private_key(const void* value,
    size_t size) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.SigningInput.private_key)
}
inline std::string* SigningInput::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SigningInput::release_private_key() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.SigningInput.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SigningInput::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.SigningInput.private_key)
}

// -------------------------------------------------------------------

// SigningOutput

// bytes signed_transaction = 1;
inline void SigningOutput::clear_signed_transaction() {
  signed_transaction_.ClearToEmpty();
}
inline const std::string& SigningOutput::signed_transaction() const {
  // @@protoc_insertion_point(field_get:TW.NEAR.Proto.SigningOutput.signed_transaction)
  return _internal_signed_transaction();
}
inline void SigningOutput::set_signed_transaction(const std::string& value) {
  _internal_set_signed_transaction(value);
  // @@protoc_insertion_point(field_set:TW.NEAR.Proto.SigningOutput.signed_transaction)
}
inline std::string* SigningOutput::mutable_signed_transaction() {
  // @@protoc_insertion_point(field_mutable:TW.NEAR.Proto.SigningOutput.signed_transaction)
  return _internal_mutable_signed_transaction();
}
inline const std::string& SigningOutput::_internal_signed_transaction() const {
  return signed_transaction_.Get();
}
inline void SigningOutput::_internal_set_signed_transaction(const std::string& value) {
  
  signed_transaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SigningOutput::set_signed_transaction(std::string&& value) {
  
  signed_transaction_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:TW.NEAR.Proto.SigningOutput.signed_transaction)
}
inline void SigningOutput::set_signed_transaction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signed_transaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:TW.NEAR.Proto.SigningOutput.signed_transaction)
}
inline void SigningOutput::set_signed_transaction(const void* value,
    size_t size) {
  
  signed_transaction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:TW.NEAR.Proto.SigningOutput.signed_transaction)
}
inline std::string* SigningOutput::_internal_mutable_signed_transaction() {
  
  return signed_transaction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SigningOutput::release_signed_transaction() {
  // @@protoc_insertion_point(field_release:TW.NEAR.Proto.SigningOutput.signed_transaction)
  return signed_transaction_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SigningOutput::set_allocated_signed_transaction(std::string* signed_transaction) {
  if (signed_transaction != nullptr) {
    
  } else {
    
  }
  signed_transaction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signed_transaction,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:TW.NEAR.Proto.SigningOutput.signed_transaction)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace NEAR
}  // namespace TW

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_NEAR_2eproto
